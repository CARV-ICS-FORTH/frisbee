package create

/*

import (
	"context"
	"fmt"

	frisbee "github.com/fnikolai/frisbee/api/v1alpha1"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/api/extensions/v1beta1"
	"k8s.io/apimachinery/pkg/util/intstr"
)


func createKubeIngress(ctx context.Context, obj *frisbee.Service, r *CreateServiceReconciler) error {
	_ = r.Log.WithValues("kubeIngress", obj.Name)


	if len(obj.Spec.Ports) == 0 || len(kubernetes.K8sClient.Ingress) == 0 {
		return nil
	}

	// create Ingress Template (only if there are declared ports)
	publicDNS := fmt.Sprintf("%s.%s", obj.GetName(), kubernetes.K8sClient.Ingress)





	ingress := v1beta1.Ingress{
		ObjectMeta: metav1.ObjectMeta{
			Name:      obj.GetName(),
			Namespace: obj.GetNamespace(),
			Labels:    obj.GetLabels(),
			OwnerReferences:             makeItOwned(obj),
			Annotations:  map[string]string {
				"ingress.kubernetes.io/rewrite-target": "/",
			},
		},
		Spec: v1beta1.IngressSpec{
			Rules: []v1beta1.IngressRule{
				{
					Host: publicDNS,
					IngressRuleValue: v1beta1.IngressRuleValue{
						HTTP: &v1beta1.HTTPIngressRuleValue{
							Paths: []v1beta1.HTTPIngressPath{
								{
									Path: "/",
									Backend: v1beta1.IngressBackend{
										ServiceName: obj.GetName(),
										ServicePort: intstr.FromInt(int(obj.Spec.Containers[0].Ports[0].ContainerPort)),
									},
								},
							},
						},
					},
				},
			},
		},
	}


	if err := r.Client.Create(ctx, &ingress); err != nil {
		return errors.Wrapf(err, "unable to create ingress")
	}

	logrus.Print("Ingress ", ingress.Status.String())

	obj.Status.IngressLink = publicDNS

	return nil
}


*/
