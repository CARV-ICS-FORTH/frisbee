# monitorTemplateRef: [ sysmon/container, redismon/telegraf ]
---
apiVersion: frisbee.io/v1alpha1
kind: Template
metadata:
  name: rediscluster
spec:
  services:
    # Master server handling a keyspace
    # Every Redis Cluster node has an additional TCP port for receiving incoming connections from other
    # Redis Cluster nodes. This port is at a fixed offset from the normal TCP port used to receive incoming
    # connections from clients. To obtain the Redis Cluster port, 10000 should be added to the normal commands port.
    # For example, if a Redis node is listening for client connections on port 6379,
    # the Cluster bus port 16379 will also be opened.
    #
    # In certain deployments, Redis Cluster nodes address discovery fails, because
    # addresses are NAT-ted or because ports are forwarded (the typical case is
    # Docker and other containers).
    #
    # In order to make Redis Cluster working in such environments, a static
    # configuration where each node knows its public address is needed.
    #
    # With that wraparound, the bootstrap stuck forever with the notorious "Waiting for the cluster to join".
    "master":
      inputs:
        parameters:
          port: "6379"
      spec: |
        container:
          name: app
          image: redis
          ports:
            - name: to-clients
              containerPort: {{.Inputs.Parameters.port}}
            - name: to-cluster
              containerPort: {{ $toClusterbus := add .Inputs.Parameters.port 10000}}{{$toClusterbus}}
          env:
            - name: podIP
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
          command:
            - /bin/sh   # Run shell
            - -c        # Read from string
            - |         # Multi-line str
              set -eum
              trap "touch /dev/shm/stop" EXIT

              echo "Start master node at {{.Inputs.Parameters.port}}"

              cat > redis.conf <<EOF
                port {{.Inputs.Parameters.port}}
                appendonly yes
                cluster-enabled yes
                cluster-config-file nodes.conf
                cluster-node-timeout 5000

                cluster-announce-ip $podIP
                cluster-announce-port {{.Inputs.Parameters.port}}
                cluster-announce-bus-port {{$toClusterbus}}
              EOF

              redis-server  redis.conf



    # Combine servers into a cluster
    # Because Redis requires IPS instead of hosts, we have to manually translate the given names to ips.
    # The servers are expected to be given in the form "Masters-0 Masters-1 Masters-2 ...."
    "bootstrap":
      inputs:
        parameters:
          servers: localhost
          ports: "6379"
      spec: |
        container:
          name: app
          image: redis
          command:
            - /bin/bash   # Run shell
            - -c        # Read from string
            - |         # Multi-line str
              set -eum

              servers=( {{.Inputs.Parameters.servers}} )
              ports=( {{.Inputs.Parameters.ports}} )

              ips=($(getent hosts ${servers[*]} | awk '{print $1}'))

              all=()
              for i in ${!ips[*]}; do
                if [ "${#ports[@]}" -eq 1 ];
                then
                      service=$(echo ${ips[$i]}:${ports[0]})
                else
                      service=$(echo ${ips[$i]}:${ports[$i]})
                fi

                all[i]=$service
              done

              echo "Create cluster from ${all[*]}"

              redis-cli --cluster create --cluster-yes ${all[*]}

    # Loader injecting keys into clustered servers
    "loader":
      inputs:
        parameters:
          server: localhost
          port: "6379"
          offset: "0"
          recordcount: "100000"
      spec: |
        monitorTemplateRef: [ sysmon/container, ycsbmon/goycsb ]
        container:
          name: app
          image: aylei/go-ycsb:20201029
          command:
            - /bin/sh   # Run shell
            - -c        # Read from string
            - |         # Multi-line str
              set -eum
              trap "touch /dev/shm/stop" EXIT

              addr={{.Inputs.Parameters.server}}:{{.Inputs.Parameters.port}}

              echo Loader: insert {{.Inputs.Parameters.recordcount}} keys into "$addr" @  {{.Inputs.Parameters.offset}}

              ./go-ycsb load redis                                                              \
                  -p recordcount={{.Inputs.Parameters.recordcount}}                             \
                  -p insertstart={{.Inputs.Parameters.offset}}                                  \
                  -p threadcount=1                                                              \
                  -p redis.mode="cluster"                                                       \
                  -p redis.addr="$addr"                                                         \
              >> /dev/shm/pipe



    # Run queries against the clustered servers
    "runner":
      inputs:
        parameters:
          server: localhost
          port: "6379"
          workload: "workloada"
          operationcount: "100000"
      spec: |
        monitorTemplateRef: [ sysmon/container, ycsbmon/goycsb ]
        container:
          name: app
          image: aylei/go-ycsb:20201029
          command:
            - /bin/sh   # Run shell
            - -c        # Read from string
            - |         # Multi-line str
              set -eum
              trap "touch /dev/shm/stop" EXIT

              addr={{.Inputs.Parameters.server}}:{{.Inputs.Parameters.port}}

              echo Runner: {{.Inputs.Parameters.workflow}} with {{.Inputs.Parameters.operationcount}} to $addr"

              ./go-ycsb run redis                                                                   \
                    -P workloads/{{.Inputs.Parameters.workload}}                                    \
                    -p operationcount={{.Inputs.Parameters.operationcount}}                         \
                    -p threadcount=1                                                                \
                    -p redis.mode="cluster"                                                         \
                    -p redis.addr="$addr"                                                           \
              >> /dev/shm/pipe