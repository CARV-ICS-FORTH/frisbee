apiVersion: frisbee.io/v1alpha1
kind: Workflow
metadata:
  name: redis-scaledown
spec:
  withTelemetry:
    importMonitors: [ "sysmon/container", "ycsbmon/client" ]
    ingress:
      host: platform.science-hangar.eu

  withTestOracle:
    pass: >-
      {{.IsSuccessful "master-killer"}} == true

  actions:

    # Step 0: bootstrap.
    # For TiKV, we must first create a placementDriver and then add the workers.
    - action: Service
      name: master
      service:
        fromTemplate:
          templateRef: tikv/placementDriver
          inputs:
            - { cpu: "4", memory: "8Gi" }

    # add a cluster of 5 TiKV instances. We use the "tolerate" directive in order to have the cluster
    # running despite the continuous fault -- kills are expected as part of the experiment.
    - action: Cluster
      depends: { running: [ master ] }
      name: workers
      cluster:
        templateRef: tikv/worker
        tolerate:
          failedServices: 5
        instances: 5
        inputs:
          - { placementDriver: .service.master.any,  cpu: "8", memory: "32Gi" }


    # Step 1: Load a new dataset, using the parameters of workload A.
    # We use no throttling to maximize this step and complete it soon.
    - action: Cluster
      name: loaders
      depends: { running: [ master, workers ] }
      cluster:
        templateRef: ycsb-tikv/loader
        inputs:
          - { server: .service.master.any, recordcount: "1000000", offset: "0", threads: "400" }


    # Step 2: Run a constant load
    - action: Cluster
      name: runners
      depends: { running: [ master, workers ], success: [ loaders ] }
      cluster:
        templateRef: ycsb-tikv/runner
        instances: 10
        inputs:
          - { server: .service.master.any, workload: workloada, operationcount: "100000000", threads: "4" }


    # Step 3: Kill TiKV instances. The two sequentially, and then all the rest immediately.
    - action: Chaos
      name: killer1
      depends: { running: [ workers, runners ] }
      chaos:
        type: kill
        kill:
          selector: { macro: .cluster.workers.any }


    - action: Chaos
      name: killer2
      depends: { running: [ workers, runners, killer1 ] }
      chaos:
        type: kill
        kill:
          selector: { macro: .cluster.workers.any }

    - action: Chaos
      name: killer3
      depends: { running: [ workers, runners, killer2 ] }
      chaos:
        type: kill
        kill:
          selector: { macro: .cluster.workers.all }