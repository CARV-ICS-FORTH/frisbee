apiVersion: frisbee.io/v1alpha1
kind: Workflow
metadata:
  name: elasticity
spec:
  importMonitors: [ "sysmon/container", "redismon/telegraf", "ycsbmon/goycsb" ]
  ingress: localhost

  actions:
    # Create a Master node
    - actiontype: ServiceGroup
      name: "masters"
      servicegroup:
        templateRef: redis/master
        instances: 1


    # Wait for master node to become ready, and ingest 100K non-overlapping keys, with 10 parallel clients
    - actiontype: ServiceGroup
      name: "loaders"
      depends: { running: [ masters ] }
      servicegroup:
        templateRef: redis/loader
        inputs:
          - { server: .servicegroup.masters.one, recordcount: "10000", offset: "0" }
          - { server: .servicegroup.masters.one, recordcount: "10000", offset: "10000" }
          - { server: .servicegroup.masters.one, recordcount: "10000", offset: "20000" }
          - { server: .servicegroup.masters.one, recordcount: "10000", offset: "30000" }
          - { server: .servicegroup.masters.one, recordcount: "10000", offset: "40000" }
          - { server: .servicegroup.masters.one, recordcount: "10000", offset: "50000" }
          - { server: .servicegroup.masters.one, recordcount: "10000", offset: "60000" }
          - { server: .servicegroup.masters.one, recordcount: "10000", offset: "70000" }
          - { server: .servicegroup.masters.one, recordcount: "10000", offset: "80000" }
          - { server: .servicegroup.masters.one, recordcount: "10000", offset: "90000" }


    # Wait for ingestion to complete, and start querying clients, with different workloads
    - actiontype: ServiceGroup
      name: "runners"
      depends: { running: [ masters ], success: [loaders] }
      servicegroup:
        templateRef: redis/runner
        inputs:
          - { server: .servicegroup.masters.one, workload: "workloada", operationcount: "100000" }
          - { server: .servicegroup.masters.one, workload: "workloadb", operationcount: "100000" }
          - { server: .servicegroup.masters.one, workload: "workloadc", operationcount: "100000" }
          - { server: .servicegroup.masters.one, workload: "workloadd", operationcount: "100000" }
          - { server: .servicegroup.masters.one, workload: "workloada", operationcount: "100000" }
        schedule:
          cron: "@every 2m"


    # Stop the masters
    - actiontype: Stop
      name: "teardown"
      depends: { success: [ runners ], duration: "1m" }
      stop:
        selector: {macro: .servicegroup.masters.all}
        schedule:
          cron: "@every 2m"

    # Wait until servers are removed
    - actiontype: Wait
      name: "terminate"
      wait:
        success: [ masters ]