## @section Global parameters
## Global Frisbee Platform parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
##
## @param global.ingress DNS name for making Telemetry stack accessible outside the cluster.
global:
  ## E.g.
  ## ingress:
  ##   - localhost
  ##   - platform.science-hangar.eu
  ingress: localhost


## @section Frisbee Operator parameters

## @param operator.enabled Set it to false for running the controller outside the Kubernetes Cluster
operator:
  enabled: true


## @section Frisbee Telemetry parameters

## @param telemetry.honorTimestamp Use the timestamps of the metrics exposed by the agent (time-drifts)
## @param telemetry.prometheusPort Listening port for Prometheus
## @param telemetry.grafanaPort Listening port for Grafana
telemetry:
  honorTimestamp: true
  prometheusPort: 9090
  grafanaPort: 3000


## @section Provision of dynamic volumes

## @param openebs.enabled Whether to enable OpenEBS
## @param openebs.storagePath The filesystem dir where volumes will be provisioned
## @param openebs.ndm.enabled Whether to enable block devices as resources
## @param openebs.ndmOperator.enabled Whether to automatically provision block devices
openebs:
  enabled: true

  storagePath: /mnt/local

  ndm:
    enabled: false

  ndmOperator:
    enabled: false

  nfs-provisioner:
    enabled: true


## @section Chaos Injection Parameters

## @param chaos.enabled Whether or not to enable the Chaos controllers
chaos-mesh:
  controllerManager:
    replicaCount: 1

  # If you are using Kind or using containerd as CRI, you can use the
  # config below to use containerd as the runtime in chaos-daemon.
  chaosDaemon:
    runtime: containerd
    socketPath: /var/snap/microk8s/common/run/containerd.sock

chaos:
  enabled: true

## @section Code Coverage Parameters

## @param sonarqube.enabled Whether or not to enable SonarQube
## @param sonarqube.persistence.enabled Whether to persist the collected coverage metrics
sonarqube:
  enabled: false

    # Ignore  deployment taints, if any.
    #tolerations:
  #  - key: "sonarqube"
  #    operator: "Equal"
  #    value: "true"
  #    effect: "NoSchedule"

  # nodeSelector:
  #  sonarqube: "true"

  # SonarQube comes with a bundled Elasticsearch and, as Elasticsearch is stateful, so is SonarQube.
  # There is an option to persist the Elasticsearch indexes in a Persistent Volume, but with regular
  # killing operations by the Kubernetes Cluster, these indexes can be corrupted.
  # By default, persistency is disabled in the Helm chart.
  persistence:
    enabled: false

      # make the SonarQube service accessible from outside of your cluster,
      #ingress:
      #enabled: true
      # Used to create an Ingress record.
      #hosts:
      #  - name: sonarqube.{{.Values.global.ingress}}
      # Different clouds or configurations might need /* as the default path
      #    path: /
    # For additional control over serviceName and servicePort
    #   serviceName: sonarqube
    # servicePort: 9000
    #annotations:
    #kubernetes.io/ingress.class: nginx
    #nginx.ingress.kubernetes.io/proxy-body-size: "8m"

  # Currently, no cloud-native monitoring solutions play nicely with SonarQube or are supported by SonarSource.
  # It is, however, possible to expose at least the JMX metrics to Prometheus with the help of the Prometheus
  # JMX exporter for the Application Nodes.
  # If enabled, it downloads the Prometheus JMX exporter agent and adds it to the startup options of SonarQube.
  # prometheusExporter:
  #  enabled: false
  #  config:
  #    rules:
  #      - pattern: ".*"



